---
layout: post
title: "《RESTful Web Services 中文版》读书笔记（二）"
date: 2019-01-27 11:00:00 +0800
categories: RESTful
tags: RESTful REST
author: Bobby
---

* content
{:toc}

最近还是继续在学习 REST、 微服务等相关知识，想从理论方面对这些知识有个更深入、更全面的了解。《RESTful Web Services 中文版》是目前正在看的。对其中有些内容作了摘录，便于以后查阅和复习。
其中，引用的书中的内容，版权归作者所有。如有侵权，请联系删除。



## 第五章 设计只读的面向资源的服务

统一接口（uniform interface）意味着，在面向对象设计里被视为动词（verb）的事物，在面向资源的设计里必须被视为对象（object）。在 ROA 里，一个读者（Reader）不能“订阅”一个栏目（Column），因为“订阅（subscribe to）”不属于统一接口里的方法。必须通过另一个订阅（Subscription）对象来代表读者与栏目的关系。这种关系对象（relationship object）是符合统一接口的：它可被创建、获取（比如通过聚合的方式）和删除。在面向对象分析里，“订阅（Subscription）”也许不是一类对象（first-class object），而是下层数据库模型里的一张表。在面向资源的分析中，所有的对象处理（object manupulation）都是通过符合统一接口的资源来实现的。如果要给我的资源添加新方法，就要为此定义一个新资源。

**创建一组响应 GET 和 HEAD（HTTP 统一接口的一个只读子集）的资源的步骤**：

1. 规划数据集

2. 把数据集划分为资源

    记住，一个资源就是**任何值得作为超链接目标的事物**。任何可能用名称来引用的事物都应该有自己的名称。服务暴露的资源可以分为三类：
    * 为特别目的专门预定义的一次性资源  
        这包括其他可用资源的最上层目录。大多数服务几乎不暴露一次性资源（one-off resources）。
    * 服务暴露的每一个对象做对应的资源  
        一个服务可以暴露很多对象，每一种都有自己的资源集合。大多数服务暴露很多（甚至无数）个这样的资源。
    * 代表在数据集上执行算法的结果的资源  
        这包括作为查询结果的集合资源。对于大多数服务，此类资源不是有无数个，就是一个也没有。

    REST 式 Web 服务通过资源（resource）来暴露数据（data）和算法（algorithms）。有关数据的资源常常构成一个层次结构（hierarchy）：由很少的资源开始，然后逐渐扩展为具有许多叶节点。

3. 用 URI 为该资源命名

    URI 能够很自然地把作用域信息组织起来。URI 设计有三条基本原则：
    1. 用路径变量（path variables）来表达层次结构（hierarchy）：/parent/child。
    2. 在路径变量里加上标点符号，以消除误解：/parent/child1;child2。  
        用逗号或分号表达非层次结构。建议：当作用域信息的次序重要时，就用逗号，否则就用分号。关于在 URI 里使用分号，还有一种矩阵 URI （matrix URIs），在 URI 里定义键值对。
    3. 用查询变量（query variables）来表达算法的输入，例如：/search?q=jellyfish&start=20。

4. 设计发给客户端的表示

    表示（representation）采用的格式要能够：（1）传达资源的当前状态；（2）链接到可能的下个应用状态或资源状态。  
    传达资源状态是表示的主要用途。“资源状态（resource state）”就是有关资源的任何信息。  
    表示的另一个用途是推进状态。一个资源的表示应该链接到邻近的资源，比如可能的下个应用状态（application state）。这样做是为了实现连通性（connectedness）——通过跟随链接（following links）从一个资源到另一个资源的能力。  

5. 用超链接和表单把该资源与已有资源联系起来

    客户端搜索的结果可能有无数种，但是我们不可能为所有搜索结果都专门列出一个链接。HTML 通过表单（Form）来解决这种问题。我们可以通过在表示里提供一个表单，告诉客户端如何在查询字符串（query string）里带入变量。该表单代表着无数个遵循一定模式的 URIs。

6. 考虑有哪些典型的事件经过

    许多只读资源的典型事件经过（course of events）都是比较简单的。用户向一个 URI 发出 GET 请求，服务器返回正确的响应代码（比如 200）、一些 HTTP 报头及一个实体主体（表示）。HEAD 请求的过程也差不多，只是服务器不发送实体主体（表示）而已。这里最重要的问题是：客户端的请求和服务器的响应里分别应包含哪些 HTTP 报头。

    **条件 HTTP GET**  
    条件 HTTP GET（conditional HTTP GET）可以节省客户端和服务器的时间与带宽。它是通过两个响应报头（Last-Modified 和 ETag）和两个请求报头（If-Modified-Since 和 If-None-Match）实现的。

7. 考虑可能出现哪些错误情况

    * 如果不存在，响应代码 404（"Not Found"），无需在 HTTP 响应里提供实体主体。  
    * 如果有相近的资源，响应代码 303（"See Other"），并在 HTTP 响应报头 Location 里给出这个资源的 URI。客户端可以自己决定是否采纳这个建议，以及是否请求那个 URI。假设没有相近的，再返回响应代码 404（"Not Found"）。  
    * 如果客户端请求有错，应该确切的响应代码 400 （"Bad Request"）。  
    * 服务器也许会因为请求太多而过载，无法处理当前请求。对于这种情况，响应代码应该是 503（"Service Unavailable"）。还有一个选择，就是拒绝处理该请求。  
    * 服务器可能会运行出错。这可能是因为数据丢失或数据错误、软件 bug、硬件故障等原因造成的。对于这种情况，响应代码应该是 500（"Inernal Server Error"）。

## 第六章 设计可读写的面向资源的服务
